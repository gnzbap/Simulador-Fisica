<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<title>Simulador de Colisiones entre Esferas</title>
<style>
  body { font-family: Arial, sans-serif; background: #f8f8f8; text-align: center; }
  .container { display: flex; justify-content: center; align-items: flex-start; gap: 30px; margin-top: 20px; }
  canvas { border: 1px solid black; background: white; display: block; }
  .controls { width: 600px; margin: 0 auto; text-align: left; }
  label { display: block; margin: 10px 0 5px; }
  .value { font-weight: bold; margin-left: 8px; }
  .velocity-label {
    position: absolute;
    background: rgba(255,255,255,0.8);
    border: 1px solid #000;
    border-radius: 4px;
    padding: 2px 5px;
    font-size: 12px;
    pointer-events: none;
  }
  #chartCanvas { border: 1px solid #000; background: #fff; }
  .buttons { margin-top: 10px; text-align: center; }
</style>
</head>
<body>

<h2>Simulador de Colisiones entre Dos Esferas</h2>

<div class="controls">
  <label> Masa esfera 1 (kg): 
    <input type="range" id="mass1" min="1" max="10" value="5" step="0.1">
    <span id="mass1Value" class="value">5</span>
  </label>

  <label> Masa esfera 2 (kg): 
    <input type="range" id="mass2" min="1" max="10" value="5" step="0.1">
    <span id="mass2Value" class="value">5</span>
  </label>

  <label> Rozamiento (0 - sin rozamiento, 1 - m√°ximo): 
    <input type="range" id="friction" min="0" max="1" step="0.01" value="0.02">
    <span id="frictionValue" class="value">0.02</span>
  </label>

  <label><input type="checkbox" id="randomBounce"> Rebote aleatorio</label>
  <div class="buttons">
    <button onclick="reset()">Reiniciar</button>
    <button onclick="togglePause()">
      <span id="pauseLabel">‚è∏ Pausar</span>
    </button>
    <button onclick="launchBall()">üé± Lanzar Esfera Roja</button>
  </div>
</div>

<div class="container">
  <div style="position: relative;">
    <canvas id="canvas" width="800" height="400"></canvas>
    <div id="vel1" class="velocity-label">v‚ÇÅ = 0.00 m/s</div>
    <div id="vel2" class="velocity-label">v‚ÇÇ = 0.00 m/s</div>
  </div>
  <canvas id="chartCanvas" width="300" height="400"></canvas>
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const chartCanvas = document.getElementById('chartCanvas');
const chartCtx = chartCanvas.getContext('2d');

// Controles
const mass1Range = document.getElementById('mass1');
const mass2Range = document.getElementById('mass2');
const frictionRange = document.getElementById('friction');
const randomBounceCheckbox = document.getElementById('randomBounce');

// Etiquetas de sliders
const mass1Value = document.getElementById('mass1Value');
const mass2Value = document.getElementById('mass2Value');
const frictionValue = document.getElementById('frictionValue');

// Etiquetas de velocidad flotantes
const vel1Label = document.getElementById('vel1');
const vel2Label = document.getElementById('vel2');

// Estado de simulaci√≥n
let paused = false;
let animationId;
let time = 0;
let data = []; // {t, v1, v2}

let sphere1, sphere2;

function reset() {
  cancelAnimationFrame(animationId);
  time = 0;
  data = [];
  sphere1 = { x: 150, y: 200, vx: 0, vy: 0, mass: parseFloat(mass1Range.value) };
  sphere2 = { x: 650, y: 200, vx: 0, vy: 0, mass: parseFloat(mass2Range.value) };
  updateRadius();
  drawChart();
  animate();
}

function updateRadius() {
  // Radio proporcional a la ra√≠z c√∫bica de la masa
  sphere1.r = 15 + 3 * Math.cbrt(sphere1.mass);
  sphere2.r = 15 + 3 * Math.cbrt(sphere2.mass);
}

[mass1Range, mass2Range, frictionRange].forEach(input => {
  input.addEventListener('input', () => {
    if (input.id === 'mass1') mass1Value.textContent = input.value;
    if (input.id === 'mass2') mass2Value.textContent = input.value;
    if (input.id === 'friction') frictionValue.textContent = input.value;
    updateRadius();
  });
});

function drawSphere(sphere, color) {
  ctx.beginPath();
  ctx.arc(sphere.x, sphere.y, sphere.r, 0, Math.PI * 2);
  ctx.fillStyle = color;
  ctx.fill();
  ctx.stroke();
}

function handleCollision(s1, s2, randomBounce) {
  const dx = s2.x - s1.x;
  const dy = s2.y - s1.y;
  const dist = Math.sqrt(dx * dx + dy * dy);
  if (dist < s1.r + s2.r) {
    const nx = dx / dist;
    const p = 2 * (s1.vx * nx - s2.vx * nx) / (s1.mass + s2.mass);
    s1.vx -= p * s2.mass * nx;
    s2.vx += p * s1.mass * nx;
    if (randomBounce) {
      s1.vx += (Math.random() - 0.5) * 0.5;
      s2.vx += (Math.random() - 0.5) * 0.5;
    }
  }
}

function updateVelocityLabels() {
  vel1Label.textContent = `v‚ÇÅ = ${sphere1.vx.toFixed(2)} m/s`;
  vel2Label.textContent = `v‚ÇÇ = ${sphere2.vx.toFixed(2)} m/s`;
  vel1Label.style.left = (canvas.offsetLeft + sphere1.x - 25) + "px";
  vel1Label.style.top  = (canvas.offsetTop + sphere1.y - sphere1.r - 25) + "px";
  vel2Label.style.left = (canvas.offsetLeft + sphere2.x - 25) + "px";
  vel2Label.style.top  = (canvas.offsetTop + sphere2.y - sphere2.r - 25) + "px";
}

function drawChart() {
  chartCtx.clearRect(0, 0, chartCanvas.width, chartCanvas.height);
  chartCtx.font = "12px Arial";
  chartCtx.fillText("Velocidad (m/s)", 100, 15);
  chartCtx.strokeStyle = "#000";
  chartCtx.beginPath();
  chartCtx.moveTo(40, 20);
  chartCtx.lineTo(40, 380);
  chartCtx.lineTo(280, 380);
  chartCtx.stroke();

  if (data.length < 2) return;

  const maxT = Math.max(...data.map(d => d.t));
  const scaleX = 240 / Math.max(1, maxT);
  const maxV = Math.max(...data.map(d => Math.max(Math.abs(d.v1), Math.abs(d.v2))), 1);
  const scaleY = 150 / maxV;

  // Esfera 1
  chartCtx.strokeStyle = "red";
  chartCtx.beginPath();
  data.forEach((d, i) => {
    const x = 40 + d.t * scaleX;
    const y = 380 - 150 - d.v1 * scaleY;
    if (i === 0) chartCtx.moveTo(x, y);
    else chartCtx.lineTo(x, y);
  });
  chartCtx.stroke();

  // Esfera 2
  chartCtx.strokeStyle = "blue";
  chartCtx.beginPath();
  data.forEach((d, i) => {
    const x = 40 + d.t * scaleX;
    const y = 380 - 150 - d.v2 * scaleY;
    if (i === 0) chartCtx.moveTo(x, y);
    else chartCtx.lineTo(x, y);
  });
  chartCtx.stroke();

  // Leyenda
  chartCtx.fillStyle = "red";
  chartCtx.fillRect(50, 360, 10, 10);
  chartCtx.fillStyle = "black";
  chartCtx.fillText("Esfera 1", 65, 370);

  chartCtx.fillStyle = "blue";
  chartCtx.fillRect(120, 360, 10, 10);
  chartCtx.fillStyle = "black";
  chartCtx.fillText("Esfera 2", 135, 370);
}

function animate() {
  const friction = parseFloat(frictionRange.value);
  const randomBounce = randomBounceCheckbox.checked;

  sphere1.mass = parseFloat(mass1Range.value);
  sphere2.mass = parseFloat(mass2Range.value);
  updateRadius();

  if (!paused) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Movimiento
    sphere1.x += sphere1.vx;
    sphere2.x += sphere2.vx;

    // Rozamiento
    sphere1.vx *= (1 - friction * 0.01);
    sphere2.vx *= (1 - friction * 0.01);

    // Colisiones con bordes
    [sphere1, sphere2].forEach(s => {
      if (s.x - s.r < 0) { s.x = s.r; s.vx = -s.vx; }
      if (s.x + s.r > canvas.width) { s.x = canvas.width - s.r; s.vx = -s.vx; }
    });

    handleCollision(sphere1, sphere2, randomBounce);

    drawSphere(sphere1, 'red');
    drawSphere(sphere2, 'blue');
    updateVelocityLabels();

    // Guardar datos para gr√°fico
    time += 0.1;
    data.push({t: time, v1: sphere1.vx, v2: sphere2.vx});
    if (data.length > 300) data.shift(); // Mantener tama√±o razonable
    drawChart();
  }

  animationId = requestAnimationFrame(animate);
}

// Controles de pausa
function togglePause() {
  paused = !paused;
  document.getElementById('pauseLabel').textContent = paused ? "‚ñ∂ Reanudar" : "‚è∏ Pausar";
}

// Lanzar esfera tipo pool
function launchBall() {
  if (paused) paused = false;
  sphere1.vx = 6 + Math.random() * 2;
  sphere2.vx = 0;
}

reset();
</script>

</body>
</html>
