<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<title>Simulador de Colisiones entre Esferas</title>
<style>
  body { font-family: Arial, sans-serif; background: #f8f8f8; text-align: center; }
  .container { display: flex; justify-content: center; align-items: flex-start; gap: 30px; margin-top: 20px; }
  canvas { border: 1px solid black; background: white; display: block; }
  .controls { width: 600px; margin: 0 auto; text-align: left; }
  label { display: block; margin: 10px 0 5px; }
  .value { font-weight: bold; margin-left: 8px; }
  .velocity-label {
    position: absolute;
    background: rgba(255,255,255,0.8);
    border: 1px solid #000;
    border-radius: 4px;
    padding: 2px 5px;
    font-size: 12px;
    pointer-events: none;
  }
  .chart-column {
    display: flex;
    flex-direction: column;
    gap: 20px;
  }
  #chartRed, #chartBlue { border: 1px solid #000; background: #fff; }
  .buttons { margin-top: 10px; text-align: center; }
</style>
</head>
<body>

<h2>Simulador de Colisiones entre Dos Esferas</h2>

<div class="controls">
  <label> Masa esfera 1 (roja, kg): 
    <input type="range" id="mass1" min="1" max="10" value="5" step="0.1">
    <span id="mass1Value" class="value">5</span>
  </label>

  <label> Masa esfera 2 (azul, kg): 
    <input type="range" id="mass2" min="1" max="10" value="5" step="0.1">
    <span id="mass2Value" class="value">5</span>
  </label>

  <label> Rozamiento (0 - sin rozamiento, 1 - m√°ximo): 
    <input type="range" id="friction" min="0" max="1" step="0.01" value="0.02">
    <span id="frictionValue" class="value">0.02</span>
  </label>

  <div class="buttons">
    <button onclick="reset()">Reiniciar</button>
    <button onclick="togglePause()">
      <span id="pauseLabel">‚è∏ Pausar</span>
    </button>
  </div>
  <p><b>Instrucci√≥n:</b> Haz clic sobre el lienzo para lanzar la esfera roja en esa direcci√≥n üé±</p>
</div>

<div class="container">
  <div style="position: relative;">
    <canvas id="canvas" width="800" height="400"></canvas>
    <div id="vel1" class="velocity-label">v‚ÇÅ = 0.00 m/s</div>
    <div id="vel2" class="velocity-label">v‚ÇÇ = 0.00 m/s</div>
  </div>
  <div class="chart-column">
    <canvas id="chartRed" width="300" height="180"></canvas>
    <canvas id="chartBlue" width="300" height="180"></canvas>
  </div>
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const chartRed = document.getElementById('chartRed').getContext('2d');
const chartBlue = document.getElementById('chartBlue').getContext('2d');

const mass1Range = document.getElementById('mass1');
const mass2Range = document.getElementById('mass2');
const frictionRange = document.getElementById('friction');

const mass1Value = document.getElementById('mass1Value');
const mass2Value = document.getElementById('mass2Value');
const frictionValue = document.getElementById('frictionValue');

const vel1Label = document.getElementById('vel1');
const vel2Label = document.getElementById('vel2');

let paused = false;
let animationId;
let time = 0;
let dataRed = [];
let dataBlue = [];
let showGuide = false;
let guideEnd = {x:0, y:0};

let sphere1, sphere2;

function reset() {
  cancelAnimationFrame(animationId);
  time = 0;
  dataRed = [];
  dataBlue = [];
  sphere1 = { x: 150, y: 200, vx: 0, vy: 0, mass: parseFloat(mass1Range.value) };
  sphere2 = { x: 650, y: 200, vx: 0, vy: 0, mass: parseFloat(mass2Range.value) };
  updateRadius();
  drawCharts();
  animate();
}

function updateRadius() {
  sphere1.r = 15 + 3 * Math.cbrt(sphere1.mass);
  sphere2.r = 15 + 3 * Math.cbrt(sphere2.mass);
}

[mass1Range, mass2Range, frictionRange].forEach(input => {
  input.addEventListener('input', () => {
    if (input.id === 'mass1') mass1Value.textContent = input.value;
    if (input.id === 'mass2') mass2Value.textContent = input.value;
    if (input.id === 'friction') frictionValue.textContent = input.value;
    updateRadius();
  });
});

function drawSphere(sphere, color) {
  ctx.beginPath();
  ctx.arc(sphere.x, sphere.y, sphere.r, 0, Math.PI * 2);
  ctx.fillStyle = color;
  ctx.fill();
  ctx.stroke();
}

function handleCollision(s1, s2) {
  const dx = s2.x - s1.x;
  const dy = s2.y - s1.y;
  const dist = Math.sqrt(dx * dx + dy * dy);
  if (dist < s1.r + s2.r) {
    const nx = dx / dist;
    const ny = dy / dist;
    const dvx = s1.vx - s2.vx;
    const dvy = s1.vy - s2.vy;
    const p = 2 * (dvx * nx + dvy * ny) / (s1.mass + s2.mass);
    s1.vx -= p * s2.mass * nx;
    s1.vy -= p * s2.mass * ny;
    s2.vx += p * s1.mass * nx;
    s2.vy += p * s1.mass * ny;
  }
}

function updateVelocityLabels() {
  const v1 = Math.sqrt(sphere1.vx ** 2 + sphere1.vy ** 2);
  const v2 = Math.sqrt(sphere2.vx ** 2 + sphere2.vy ** 2);
  vel1Label.textContent = `v‚ÇÅ = ${v1.toFixed(2)} m/s`;
  vel2Label.textContent = `v‚ÇÇ = ${v2.toFixed(2)} m/s`;
  vel1Label.style.left = (canvas.offsetLeft + sphere1.x - 25) + "px";
  vel1Label.style.top  = (canvas.offsetTop + sphere1.y - sphere1.r - 25) + "px";
  vel2Label.style.left = (canvas.offsetLeft + sphere2.x - 25) + "px";
  vel2Label.style.top  = (canvas.offsetTop + sphere2.y - sphere2.r - 25) + "px";
}

function drawCharts() {
  drawVelocityChart(chartRed, dataRed, "red", "Velocidad Esfera Roja");
  drawVelocityChart(chartBlue, dataBlue, "blue", "Velocidad Esfera Azul");
}

function drawVelocityChart(ctxChart, data, color, title) {
  ctxChart.clearRect(0, 0, 300, 180);
  ctxChart.font = "12px Arial";
  ctxChart.fillStyle = "#000";
  ctxChart.fillText(title, 70, 15);

  ctxChart.strokeStyle = "#000";
  ctxChart.beginPath();
  ctxChart.moveTo(40, 20);
  ctxChart.lineTo(40, 160);
  ctxChart.lineTo(280, 160);
  ctxChart.stroke();

  if (data.length < 2) return;

  const maxT = Math.max(...data.map(d => d.t));
  const maxV = Math.max(...data.map(d => Math.abs(d.v)), 1);
  const scaleX = 220 / Math.max(1, maxT);
  const scaleY = 100 / maxV;

  ctxChart.strokeStyle = color;
  ctxChart.beginPath();
  data.forEach((d, i) => {
    const x = 40 + d.t * scaleX;
    const y = 160 - d.v * scaleY;
    if (i === 0) ctxChart.moveTo(x, y);
    else ctxChart.lineTo(x, y);
  });
  ctxChart.stroke();
}

function animate() {
  const friction = parseFloat(frictionRange.value);
  sphere1.mass = parseFloat(mass1Range.value);
  sphere2.mass = parseFloat(mass2Range.value);
  updateRadius();

  if (!paused) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Movimiento
    sphere1.x += sphere1.vx;
    sphere1.y += sphere1.vy;
    sphere2.x += sphere2.vx;
    sphere2.y += sphere2.vy;

    // Rozamiento
    sphere1.vx *= (1 - friction * 0.01);
    sphere1.vy *= (1 - friction * 0.01);
    sphere2.vx *= (1 - friction * 0.01);
    sphere2.vy *= (1 - friction * 0.01);

    // Bordes
    [sphere1, sphere2].forEach(s => {
      if (s.x - s.r < 0) { s.x = s.r; s.vx = -s.vx; }
      if (s.x + s.r > canvas.width) { s.x = canvas.width - s.r; s.vx = -s.vx; }
      if (s.y - s.r < 0) { s.y = s.r; s.vy = -s.vy; }
      if (s.y + s.r > canvas.height) { s.y = canvas.height - s.r; s.vy = -s.vy; }
    });

    handleCollision(sphere1, sphere2);

    drawSphere(sphere1, 'red');
    drawSphere(sphere2, 'blue');

    // Gu√≠a de lanzamiento
    if (showGuide) {
      ctx.beginPath();
      ctx.moveTo(sphere1.x, sphere1.y);
      ctx.lineTo(guideEnd.x, guideEnd.y);
      ctx.strokeStyle = 'rgba(0,0,0,0.4)';
      ctx.setLineDash([5,5]);
      ctx.stroke();
      ctx.setLineDash([]);
    }

    updateVelocityLabels();

    // Registrar datos
    time += 0.1;
    const v1 = Math.sqrt(sphere1.vx ** 2 + sphere1.vy ** 2);
    const v2 = Math.sqrt(sphere2.vx ** 2 + sphere2.vy ** 2);
    dataRed.push({t: time, v: v1});
    dataBlue.push({t: time, v: v2});
    if (dataRed.length > 300) dataRed.shift();
    if (dataBlue.length > 300) dataBlue.shift();

    drawCharts();
  }

  animationId = requestAnimationFrame(animate);
}

// Control de pausa
function togglePause() {
  paused = !paused;
  document.getElementById('pauseLabel').textContent = paused ? "‚ñ∂ Reanudar" : "‚è∏ Pausar";
}

// Lanzamiento con clic
let isMouseDown = false;
canvas.addEventListener('mousedown', (e) => {
  isMouseDown = true;
  showGuide = true;
  const rect = canvas.getBoundingClientRect();
  guideEnd.x = e.clientX - rect.left;
  guideEnd.y = e.clientY - rect.top;
});

canvas.addEventListener('mousemove', (e) => {
  if (!isMouseDown) return;
  const rect = canvas.getBoundingClientRect();
  guideEnd.x = e.clientX - rect.left;
  guideEnd.y = e.clientY - rect.top;
});

canvas.addEventListener('mouseup', (e) => {
  if (!isMouseDown) return;
  isMouseDown = false;
  showGuide = false;
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  const dx = x - sphere1.x;
  const dy = y - sphere1.y;
  const dist = Math.sqrt(dx * dx + dy * dy);
  const speed = Math.min(dist / 20, 8); // limitar velocidad m√°xima
  const angle = Math.atan2(dy, dx);
  sphere1.vx = Math.cos(angle) * speed;
  sphere1.vy = Math.sin(angle) * speed;
});

reset();
</script>

</body>
</html>
