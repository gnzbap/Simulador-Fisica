<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Simulador de Colisiones con Energías</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<style>
  body {
    font-family: Arial, sans-serif;
    text-align: center;
    background: #f4f4f4;
    margin: 0;
    padding: 20px;
  }
  canvas {
    background: white;
    border: 2px solid #333;
    border-radius: 10px;
    display: block;
    margin: 10px auto;
  }
  .controls {
    background: #fff;
    border: 1px solid #ccc;
    border-radius: 10px;
    padding: 15px;
    margin-bottom: 15px;
    display: inline-block;
  }
  .control-group {
    margin: 10px;
  }
</style>
</head>
<body>
<h1>Simulador de Colisiones con Energías</h1>

<div class="controls">
  <div class="control-group">
    <label>Masa A (kg): </label>
    <input type="number" id="massA" value="2" step="0.1">
    <label>Masa B (kg): </label>
    <input type="number" id="massB" value="1" step="0.1">
  </div>

  <div class="control-group">
    <label>Rozamiento (0–1): </label>
    <input type="number" id="friction" value="0.01" step="0.01" min="0" max="1">
  </div>

  <div class="control-group">
    <label>Coeficiente de restitución (0–1): </label>
    <input type="number" id="restitution" value="0.9" step="0.1" min="0" max="1">
  </div>

  <button onclick="resetSimulation()">Reiniciar simulación</button>
</div>

<canvas id="simCanvas" width="600" height="300"></canvas>
<h3>Energías en función del tiempo</h3>
<canvas id="energyChart" width="600" height="250"></canvas>

<script>
const canvas = document.getElementById('simCanvas');
const ctx = canvas.getContext('2d');
const width = canvas.width;
const height = canvas.height;

let ballA, ballB, friction, restitution;
let time = 0;
let energyData = { time: [], ECA: [], ECB: [], EPA: [], EPB: [] };

function randomVelocity() {
  return (Math.random() * 2 - 1) * 100;
}

// Inicialización del sistema
function init() {
  const mA = parseFloat(document.getElementById('massA').value);
  const mB = parseFloat(document.getElementById('massB').value);
  friction = parseFloat(document.getElementById('friction').value);
  restitution = parseFloat(document.getElementById('restitution').value);

  const rA = 10 + mA * 5;
  const rB = 10 + mB * 5;

  ballA = { x: 150, y: 150, vx: randomVelocity(), vy: randomVelocity(), r: rA, m: mA, color: "red" };
  ballB = { x: 450, y: 150, vx: randomVelocity(), vy: randomVelocity(), r: rB, m: mB, color: "blue" };

  time = 0;
  energyData = { time: [], ECA: [], ECB: [], EPA: [], EPB: [] };
}

// Actualización física
function update(dt) {
  [ballA, ballB].forEach(ball => {
    ball.x += ball.vx * dt;
    ball.y += ball.vy * dt;

    // Aplicar rozamiento
    ball.vx *= (1 - friction * dt);
    ball.vy *= (1 - friction * dt);

    // Rebote con los bordes (en los 4 lados)
    if (ball.x - ball.r < 0 || ball.x + ball.r > width) {
      ball.vx *= -restitution;
      ball.x = Math.max(ball.r, Math.min(width - ball.r, ball.x));
    }
    if (ball.y - ball.r < 0 || ball.y + ball.r > height) {
      ball.vy *= -restitution;
      ball.y = Math.max(ball.r, Math.min(height - ball.r, ball.y));
    }
  });

  // Colisión entre las bolas
  const dx = ballB.x - ballA.x;
  const dy = ballB.y - ballA.y;
  const dist = Math.sqrt(dx * dx + dy * dy);

  if (dist < ballA.r + ballB.r) {
    const nx = dx / dist;
    const ny = dy / dist;
    const p = 2 * (ballA.vx * nx + ballA.vy * ny - ballB.vx * nx - ballB.vy * ny) / (ballA.m + ballB.m);
    ballA.vx -= p * ballB.m * nx * restitution;
    ballA.vy -= p * ballB.m * ny * restitution;
    ballB.vx += p * ballA.m * nx * restitution;
    ballB.vy += p * ballA.m * ny * restitution;
  }

  // Calcular energías
  const g = 9.8;
  const ECA = 0.5 * ballA.m * (ballA.vx**2 + ballA.vy**2);
  const ECB = 0.5 * ballB.m * (ballB.vx**2 + ballB.vy**2);
  const EPA = ballA.m * g * (height - ballA.y);
  const EPB = ballB.m * g * (height - ballB.y);

  energyData.time.push(time);
  energyData.ECA.push(ECA);
  energyData.ECB.push(ECB);
  energyData.EPA.push(EPA);
  energyData.EPB.push(EPB);

  time += dt;
}

// Dibujar las bolas
function draw() {
  ctx.clearRect(0, 0, width, height);
  [ballA, ballB].forEach(ball => {
    ctx.beginPath();
    ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI * 2);
    ctx.fillStyle = ball.color;
    ctx.fill();
    ctx.closePath();
  });
}

// Gráfico de energías
const energyChart = new Chart(document.getElementById('energyChart'), {
  type: 'line',
  data: { labels: [], datasets: [
    { label: 'E. Cinética A', borderColor: 'red', data: [], fill: false },
    { label: 'E. Cinética B', borderColor: 'blue', data: [], fill: false },
    { label: 'E. Potencial A', borderColor: 'orange', data: [], fill: false },
    { label: 'E. Potencial B', borderColor: 'cyan', data: [], fill: false },
  ]},
  options: {
    animation: false,
    scales: { y: { beginAtZero: true } },
    plugins: { legend: { position: 'bottom' } }
  }
});

// Actualización de gráficos
function updateCharts() {
  if (energyData.time.length % 5 === 0) {
    energyChart.data.labels = energyData.time;
    energyChart.data.datasets[0].data = energyData.ECA;
    energyChart.data.datasets[1].data = energyData.ECB;
    energyChart.data.datasets[2].data = energyData.EPA;
    energyChart.data.datasets[3].data = energyData.EPB;
    energyChart.update();
  }
}

// Bucle principal
function loop() {
  update(0.02);
  draw();
  updateCharts();
  requestAnimationFrame(loop);
}

// Reiniciar simulación
function resetSimulation() {
  init();
}

init();
loop();
</script>
</body>
</html>
